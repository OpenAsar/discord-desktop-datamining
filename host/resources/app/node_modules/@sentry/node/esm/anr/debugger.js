import { _optionalChain } from '@sentry/utils/esm/buildPolyfills';
import { dropUndefinedKeys, filenameIsInApp } from '@sentry/utils';
import { getModuleFromFilename } from '../module.js';
import { createWebSocketClient } from './websocket.js';

/**
 * Converts Debugger.CallFrame to Sentry StackFrame
 */
function callFrameToStackFrame(
  frame,
  filenameFromScriptId,
) {
  const filename = _optionalChain([filenameFromScriptId, 'call', _ => _(frame.location.scriptId), 'optionalAccess', _2 => _2.replace, 'call', _3 => _3(/^file:\/\//, '')]);

  // CallFrame row/col are 0 based, whereas StackFrame are 1 based
  const colno = frame.location.columnNumber ? frame.location.columnNumber + 1 : undefined;
  const lineno = frame.location.lineNumber ? frame.location.lineNumber + 1 : undefined;

  return dropUndefinedKeys({
    filename,
    module: getModuleFromFilename(filename),
    function: frame.functionName || '?',
    colno,
    lineno,
    in_app: filename ? filenameIsInApp(filename) : undefined,
  });
}

// The only messages we care about

/**
 * Wraps a websocket connection with the basic logic of the Node debugger protocol.
 * @param url The URL to connect to
 * @param onMessage A callback that will be called with each return message from the debugger
 * @returns A function that can be used to send commands to the debugger
 */
async function webSocketDebugger(
  url,
  onMessage,
) {
  let id = 0;
  const webSocket = await createWebSocketClient(url);

  webSocket.on('message', (data) => {
    const message = JSON.parse(data.toString()) ;
    onMessage(message);
  });

  return (method, params) => {
    webSocket.send(JSON.stringify({ id: id++, method, params }));
  };
}

/**
 * Captures stack traces from the Node debugger.
 * @param url The URL to connect to
 * @param callback A callback that will be called with the stack frames
 * @returns A function that triggers the debugger to pause and capture a stack trace
 */
async function captureStackTrace(url, callback) {
  // Collect scriptId -> url map so we can look up the filenames later
  const scripts = new Map();

  const sendCommand = await webSocketDebugger(url, message => {
    if (message.method === 'Debugger.scriptParsed') {
      scripts.set(message.params.scriptId, message.params.url);
    } else if (message.method === 'Debugger.paused') {
      // copy the frames
      const callFrames = [...message.params.callFrames];
      // and resume immediately!
      sendCommand('Debugger.resume');
      sendCommand('Debugger.disable');

      const frames = callFrames
        .map(frame => callFrameToStackFrame(frame, id => scripts.get(id)))
        // Sentry expects the frames to be in the opposite order
        .reverse();

      callback(frames);
    }
  });

  return () => {
    sendCommand('Debugger.enable');
    sendCommand('Debugger.pause');
  };
}

export { captureStackTrace };
//# sourceMappingURL=debugger.js.map
