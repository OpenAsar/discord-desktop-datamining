const core = require('@sentry/core');
const electron = require('electron');
const electronNormalize = require('../electron-normalize.js');
const sessions = require('../sessions.js');

function focusedWindow() {
    for (const window of electron.BrowserWindow.getAllWindows()) {
        if (!window.isDestroyed() && window.webContents && !window.webContents.isDestroyed()) {
            // It's important to test both isVisible and isFocused, since
            // Electron v12-13 do not report hidden as a loss of focus
            if (window.isFocused() && window.isVisible()) {
                return true;
            }
        }
    }
    return false;
}
const INTEGRATION_NAME = 'BrowserWindowSession';
/**
 * Tracks sessions as BrowserWindows focus.
 *
 * Supports Electron >= v12
 */
const browserWindowSessionIntegration = core.defineIntegration((options = {}) => {
    if (electronNormalize.ELECTRON_MAJOR_VERSION < 12) {
        throw new Error('BrowserWindowSession requires Electron >= v12');
    }
    let _state = { name: 'inactive' };
    function windowStateChanged() {
        var _a;
        const hasFocusedWindow = focusedWindow();
        if (hasFocusedWindow) {
            // We are now active
            if (_state.name === 'inactive') {
                // If we were inactive, start a new session
                sessions.startSession(true);
            }
            else if (_state.name === 'timeout') {
                // Clear the timeout since the app has become active again
                clearTimeout(_state.timer);
            }
            _state = { name: 'active' };
        }
        else {
            if (_state.name === 'active') {
                // We have become inactive, start the timeout
                const timeout = ((_a = options.backgroundTimeoutSeconds) !== null && _a !== void 0 ? _a : 30) * 1000;
                const timer = setTimeout(() => {
                    // if the state says we're still waiting for the timeout, end the session
                    if (_state.name === 'timeout') {
                        _state = { name: 'inactive' };
                        sessions.endSession().catch(() => {
                            // ignore
                        });
                    }
                }, timeout)
                    // unref so this timer doesn't block app exit
                    .unref();
                _state = { name: 'timeout', timer };
            }
        }
    }
    return {
        name: INTEGRATION_NAME,
        setupOnce() {
            // noop
        },
        setup() {
            electron.app.on('browser-window-created', (_event, window) => {
                window.on('focus', windowStateChanged);
                window.on('blur', windowStateChanged);
                window.on('show', windowStateChanged);
                window.on('hide', windowStateChanged);
                // when the window is closed we need to remove the listeners
                window.once('closed', () => {
                    window.removeListener('focus', windowStateChanged);
                    window.removeListener('blur', windowStateChanged);
                    window.removeListener('show', windowStateChanged);
                    window.removeListener('hide', windowStateChanged);
                });
            });
            // if the app exits while the session is active, end the session
            sessions.endSessionOnExit();
        },
    };
});
/**
 * Tracks sessions as BrowserWindows focus.
 *
 * Supports Electron >= v12
 *
 * @deprecated Use `browserWindowSessionIntegration()` instead
 */
// eslint-disable-next-line deprecation/deprecation
const BrowserWindowSession = core.convertIntegrationFnToClass(INTEGRATION_NAME, browserWindowSessionIntegration);

exports.BrowserWindowSession = BrowserWindowSession;
exports.browserWindowSessionIntegration = browserWindowSessionIntegration;
//# sourceMappingURL=browser-window-session.js.map
